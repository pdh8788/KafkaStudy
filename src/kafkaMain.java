public class kafkaMain {

    /**
     * 1. 카프카의 구성
     *  - 카프카는 크게 프로듀서, 카프카(브로커), 컨슈머, 주키퍼로 구성되어 있다.
     *  1) 주키퍼
     *   주키퍼는 컨슈머와 통신하는 부분 외에도 카프카와 직접 통신을 하면서, 카프카의 메타데이터 정보를 주키퍼에 저장하고,
     *   카프카의 상태관리 등의 목적으로 주키퍼를 이용합니다. 이렇게 카프카는 주키퍼와 긴밀하게 통신을 하기 때문에
     *   주키퍼 사용이 필수 조건입니다.
     *
     *   최근 들어 하둡, 나이파이, 에이치베이스, 스톰 등 많은 애플리케이션이 부하 분산 및 확장이 용이한 분산 애플리케이션으로
     *   개발되고 있습니다. 하지만 이러한 분산 애플리케이션을 사용하게 되면, 분산 애플리케이션 관리를 위한
     *   안정적인 코디네이션 애플레키이션이 추가로 필요하게 됩니다.
     *
     *   분산 애플리케이션을 개발하면서 동시에 코디네이션 애플리케이션도 개발하다 보면, 코디네이션 애플리케이션을 위한
     *   추가적인 개발 리소스가 필요하게 되므로, 이미 안정적인 코디네이션 서비스로 검증된 주키퍼를 많이 사용하고 있습니다.
     *
     *   주키퍼는 분산 애플리케이션을 위한 코디네이션 시스템입니다. 분산 애플리케이션이 안정적인 서비스를 할 수 있도록
     *   분산되어 있는 각 애플리케이션의 정보를 중앙에 집중하고 구성 관리, 그룹 관리 네이밍, 동기화 등의 서비스를 제공합니다.
     *
     *   주키퍼는 서버 여러 대를 앙상블로 구성하고, 분산 애플리케이션들이 각각 클라이언트가 되어 주키퍼 서버들과 커넥션을 맺은 후 상태 정보등을
     *   주고받게 됩니다. 상태 정보들은 주키퍼의 지노드라 불리는 곳에 키 값 형태로 저장하고, 지노드에 키 값이 저장된 것을 이용하여
     *   분산 애플리케이션들은 서로 데이터를 주고받게 됩니다.
     *
     *  지노드는 우리가 알고 있는 일반적인 디렉토리와 비슷한 형태로서 자식 노드를 가지고 있는 계층형 구조로 구성되어 있습니다.
     *  주키퍼의 각 지노드는 데이터 변경 등에 대한 유효성 검사 등을 위해 버전 번호를 관리하게 되며, 지노드의
     *  데이터가 변경될 때마다 지노드의 버전 번호가 증가합니다.
     *
     *  저장용으로 설계된 일반적인 파일시스템과 달리 주키퍼에 저장되는 데이터는 모두 메모리에 저장되어 처리량이 매우 크고
     *  속도 또한 매우 빠릅니다. 또한 주키퍼는 좀 더 신뢰성 있는 서비스를 위해 앙상블이라는 호스트 세트를 구성할 수 있습니다.
     *  앙상블로 구성되어 있는 주키퍼는 과반수 방식에 따라 살아 있는 노드 수가 과반수 이상 유지된다면 지속적인 서비스가 가능합니다.
     *
     *  1-1) 주키퍼 환경설정
     *  tickTime = 2000 // 주키퍼가 사용하는 시간에 대한 기본 측정 단위 (밀리초)
     *  initLimit = 10 // 팔로워가 리더와 초기에 연결하는 시간에 대한 타임 아웃 tick의 수
     *  syncLimit = 5 // synclimit: 팔로워가 리더와 동기화 하는 시간에 대한 타임아웃 tick의 수
     *  dataDir = /data // 주키퍼의 트랜잭션 로그와 스냅샷이 저장되는 데이터 저장 경룁니다.
     *  clientPort: 주키퍼 사용 TCP 포트
     *  server.x : 주키퍼 앙상블 구성을 위한 서버 설정이며, server.myid 형식으로 사용합니다.
     *
     *  1-2) 카프카 설치 및 환경설정
     *  클러스터 구성을 할 수 있는 분산 애플리케이션의 한 종류인 카프카는 클러스터를 구성하는 서버 대수를 정해야 합니다.
     *  다만, 분산 애플리케이션이라는 면에서 보면 주키퍼와 동일하지만 운영되는 방식입낟.
     *  과반수 방식으로 운영되어 홀수로 서버를 구성해야 하는 카프카 클러스터는 홀수 운영 서버를 하지 않아도 됩니다.
     *
     *  broker.id=1 // 브로커 아이디 설정
     *  log.dirs=/data1, /data2 // 물리적 디스크를 여러 사용하는 경우를 위해 /data1, /data2의 2개로 준비
     *  zookeeper.connect = peter-zk001:2181, peter-zk002:2181, peter-zk003:2181/peter-kafka
     *
     *  delete.topic.enable : 토픽 삭제 기능 on/off
     *  default.replication.factor : 리플리케이션 팩터 옵션을 주지 않았을 경우의 기본값
     *  min.insync.replicas : 최소 리플리케이션 팩터
     *  auto.create.topics.enable : 존재하지 않은 토픽으로 퍼블리셔가 메시지를 보냈을 때 자동으로 토픽 생성
     *  ... 88page
     *
     *  2. 카프카 상태 확인
     *  2-1) TCP 포트 확인
     *  주키퍼의 기본 TCP 포트는 2181이고, 카프카의 기본 TCP 포트는 9092입니다.
     *  포트가 리스닝 상태라는 의미는 애플리케이션이 TCP를 사용하는 서버에서 실행중이고 다른 컴퓨터와 연결될 때까지 기다린다는 것으로서,
     *  다른 말로는 수신 대기입니다.
     *  -- netstat -ntlp | grep 2181 -> 상태값 LISTEN 확인
     *
     *  2-2) 카프카 로그 확인
     *  -- cat /usr/local/kafka/logs/server.log
     *
     *
    *
     *
     */


    public static void main(String[] args) {

    }

}
